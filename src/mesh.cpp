#include "mesh.h"

Mesh::Mesh(double xmin, double xmax, double ymin, double ymax, int res_x, int res_y)
{
    // set physical size of mesh
    this->width = xmax - xmin;
    this->height = ymax - ymin;

    // set poisson domain resolution
    this->res_x = res_x;
    this->res_y = res_y;

    generate_structured_mesh(res_x, res_y, this->width, this->height, this->triangles, this->source_points);

    for (int i = 0; i < this->source_points.size(); i++)
    {
        this->source_points[i][0] += xmin;
        this->source_points[i][1] += ymin;
    }
    

    //generate_poked_mesh(res_x, res_y, width, height, this->triangles, this->source_points);
    
    build_vertex_to_triangles();

    //this->source_points = circular_transform(this->source_points);

    this->bvh = new Bvh(this->triangles, this->source_points);
}

Mesh::Mesh(std::vector<std::vector<double>> new_points, std::vector<std::vector<unsigned int>> new_triangles)
{
    for (int i = 0; i < new_points.size(); i++)
    {
        this->source_points.push_back(new_points[i]);
    }

    for (int i = 0; i < new_triangles.size(); i++)
    {
        this->triangles.push_back(new_triangles[i]);
    }

    build_vertex_to_triangles();

    this->bvh = new Bvh(this->triangles, this->source_points);
}

Mesh::~Mesh()
{
}

void Mesh::build_bvh(int targetCellSize, int maxDepth) {
    this->bvh->build(targetCellSize, maxDepth);
}

void Mesh::make_circular() {
    this->source_points = circular_transform(this->source_points);
}

void find_perimeter_vertices(int nx, int ny, std::vector<int> &perimeter_vertices) {
    // Top row
    for (int i = 0; i < nx; ++i) {
        perimeter_vertices.push_back(i);
    }

    // Right column
    for (int i = nx - 1; i < nx * ny; i += nx) {
        perimeter_vertices.push_back(i);
    }

    // Bottom row
    for (int i = nx * (ny - 1) + nx - 1; i > nx * (ny - 1) - 1; --i) {
        perimeter_vertices.push_back(i);
    }

    // Left column
    for (int i = nx * (ny - 1) - nx; i > nx - 1; i -= nx) {
        perimeter_vertices.push_back(i);
    }
}

void save_solid_obj(std::vector<std::vector<double>> &front_points, std::vector<std::vector<double>> &back_points, std::vector<std::vector<unsigned int>> &triangles, double thickness, double width, double height, int res_x, int res_y, const std::string& filename) {
    int num_points = front_points.size();

    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Error opening file: " << filename << std::endl;
        return;
    }

    // Find maximum height
    double min_h = 0;
    for (int i=0; i<num_points; i++) {
        double h = front_points[i][2];

        if (min_h > h) {
            min_h = h;
        }
    }

    file << "# Generated by the software algorithm written by Dylan Missuwe" << "\n";
    file << "# The algorithm used to create the lens is based on the paper " 
        << "\"Poisson-Based Continuous Surface Generation for Goal-Based Caustics\" " 
        << "by Yue et al (2014)" << "\n";

    // Curved mesh verts on the bottom
    for (const auto& point : front_points) {
        file << "v " << width - point[0] << " " << height - point[1] << " " << -(point[2]) << "\n";
    }

    // Flat mesh verts on the bottom
    for (const auto& point : back_points) {
        file << "v " << width - point[0] << " " << height - point[1] << " " << -thickness - min_h << "\n";
    }

    // Curved mesh triangles on the top
    for (const auto& triangle : triangles) {
        file << "f " << triangle[0] + 1 << " " << triangle[1] + 1 << " " << triangle[2] + 1 << "\n";
    }

    // Flat mesh triangles on the bottom
    for (const auto& triangle : triangles) {
        file << "f " << triangle[0] + num_points + 1 << " " << triangle[2] + num_points + 1 << " " << triangle[1] + num_points + 1 << "\n";
    }

    // Generate triangles connecting top and bottom mesh
    std::vector<int> perimeter_verts;
    find_perimeter_vertices(res_x, res_y, perimeter_verts);

    for (size_t i = 0; i < perimeter_verts.size(); ++i) {
        int top_idx = perimeter_verts[i];
        int bottom_idx = perimeter_verts[i] + num_points;
        int next_top_idx = perimeter_verts[(i + 1) % perimeter_verts.size()];
        int next_bottom_idx = perimeter_verts[(i + 1) % perimeter_verts.size()] + num_points;


        file << "f " << top_idx + 1 << " " << bottom_idx + 1 << " " << next_bottom_idx + 1 << "\n";
        file << "f " << top_idx + 1 << " " << next_bottom_idx + 1 << " " << next_top_idx + 1 << "\n";
        //file << "f " << top_idx + 1 << " " << next_bottom_idx + 1 << " " << bottom_idx + 1 << "\n";
        //file << "f " << top_idx + 1 << " " << next_top_idx + 1 << " " << next_bottom_idx + 1 << "\n";
    }

    //std::cout << "Exported model \"" << filename << "\"" << std::endl;
}

void Mesh::generate_poked_mesh(int nx, int ny, double width, double height, std::vector<std::vector<unsigned int>> &triangles, std::vector<std::vector<double>> &points) {
    double dx = width / (double)nx;
    double dy = height / (double)ny;

    // grid vertices
    for (int y=0; y<ny + 1; y++){
        for (int x=0; x<nx + 1; x++){
            points.push_back({x*dx, y*dy, 0.0f});
        }
    }

    // center vertices
    for (int y=0; y<ny; y++){
        for (int x=0; x<nx; x++){
            points.push_back({(x + 0.5f)*dx, (y + 0.5f)*dy, 0.0f});
        }
    }

    int offset = (nx + 1) * (ny + 1);
    for (int y=0; y<ny; y++){
        for (int x=0; x<nx; x++){
            unsigned int upper_left = x + y * (nx + 1);
            unsigned int upper_right = (x + 1) + y * (nx + 1);
            unsigned int lower_left = x + (y + 1) * (nx + 1);
            unsigned int lower_right = (x + 1) + (y + 1) * (nx + 1);
            unsigned int center = offset + x + y * (nx);

            triangles.push_back({upper_left, upper_right, center});
            triangles.push_back({lower_left, upper_left, center});
            triangles.push_back({lower_right, lower_left, center});
            triangles.push_back({upper_right, lower_right, center});
        }
    }
}

// generates a structured triangulation used for the parameterization
void Mesh::generate_structured_mesh(int nx, int ny, double width, double height, std::vector<std::vector<unsigned int>> &triangles, std::vector<std::vector<double>> &points) {
    printf("%i, %i, %f, %f\r\n", nx, ny, width, height);
    // Generate points
    for (int i = 0; i < ny; ++i) {
        for (int j = 0; j < nx; ++j) {
            double x = static_cast<double>(j) * width / (nx - 1);
            double y = static_cast<double>(i) * height / (ny - 1);
            points.push_back({x, y, 0.0});
        }
    }

    // Generate triangles
    for (int i = 0; i < ny - 1; ++i) {
        for (int j = 0; j < nx - 1; ++j) {
            unsigned int idx = i * nx + j;
            triangles.push_back({idx, idx + 1, idx + nx});
            triangles.push_back({idx + nx, idx + 1, idx + nx + 1});
        }
    }
}

// transforms a square grid into a circular grid -> to support circular lenses in the future
/*void Mesh::circular_transform(std::vector<std::vector<double>> &input_points) {
    for (int i = 0; i < input_points.size(); i++) {
        double x = input_points[i][0] - this->width/2.0f;
        double y = input_points[i][1] - this->height/2.0f;

        input_points[i][0] = x * sqrt(1.0 - 2.0*(y * y));
        input_points[i][1] = y * sqrt(1.0 - 2.0*(x * x));

        input_points[i][0] += this->width/2.0f;
        input_points[i][1] += this->height/2.0f;
    }
}*/

std::vector<std::vector<double>> Mesh::circular_transform(std::vector<std::vector<double>> &input_points) {
    std::vector<std::vector<double>> transformed_points;
    for (int i = 0; i < input_points.size(); i++) {
        std::vector<double> transformed_point(3);

        double x = input_points[i][0] - this->width/2.0f;
        double y = input_points[i][1] - this->height/2.0f;

        transformed_point[0] = x * sqrt(1.0 - 2.0*(y * y));
        transformed_point[1] = y * sqrt(1.0 - 2.0*(x * x));

        transformed_point[0] += this->width/2.0f;
        transformed_point[1] += this->height/2.0f;
        transformed_point[2] = input_points[i][2];

        transformed_points.push_back(transformed_point);
    }
    return transformed_points;
}

// build mapping from vertices to adjecent triangles -> used for creating dual cells
void Mesh::build_vertex_to_triangles() {
    for (int i = 0; i < this->triangles.size(); ++i) {
        const std::vector<unsigned int>& triangle = this->triangles[i];
        
        for (int vertex : triangle) {
            if (this->vertex_to_triangles.find(vertex) == this->vertex_to_triangles.end()) {
                this->vertex_to_triangles[vertex] = std::vector<int>();
            }

            this->vertex_to_triangles[vertex].push_back(i);
        }
    }
}

// find triangles, edges, and neighboring vertices connected to a specific vertex by index
std::tuple<std::vector<std::pair<int, int>>, std::vector<int>, std::vector<int>> Mesh::find_adjacent_elements(int vertex_index) {
    std::unordered_set<std::pair<int, int>, HashPair> adjacent_edges;
    std::unordered_set<int> adjacent_triangles;
    std::unordered_set<int> neighboring_vertices;

    // Find triangles containing the vertex
    auto triangles_containing_vertex = vertex_to_triangles.find(vertex_index);
    if (triangles_containing_vertex != vertex_to_triangles.end()) {
        for (int triangle_index : triangles_containing_vertex->second) {
            adjacent_triangles.insert(triangle_index);
            const std::vector<unsigned int>& triangle = triangles[triangle_index];

            // Find edges and neighboring vertices directly connected to the vertex
            for (int j = 0; j < 3; ++j) {
                int v1 = triangle[j];
                int v2 = triangle[(j + 1) % 3];

                // Add edge if it involves the vertex
                if (vertex_index == v1 || vertex_index == v2) {
                    adjacent_edges.insert(std::make_pair(std::min(v1, v2), std::max(v1, v2)));
                }

                // Add neighboring vertex (other vertex of the edge if it's not the input vertex)
                if (v1 == vertex_index) {
                    neighboring_vertices.insert(v2);
                } else if (v2 == vertex_index) {
                    neighboring_vertices.insert(v1);
                }
            }
        }
    }

    // Convert sets to vectors
    std::vector<std::pair<int, int>> adjacent_edges_vector(adjacent_edges.begin(), adjacent_edges.end());
    std::vector<int> adjacent_triangles_vector(adjacent_triangles.begin(), adjacent_triangles.end());
    std::vector<int> neighboring_vertices_vector(neighboring_vertices.begin(), neighboring_vertices.end());

    return std::make_tuple(adjacent_edges_vector, adjacent_triangles_vector, neighboring_vertices_vector);
}

std::vector<double> calculate_polygon_centroid(std::vector<std::vector<double>> vertices) {
    std::vector<double> centroid;
    centroid.push_back(0.0);
    centroid.push_back(0.0);

    double signed_area = 0;

    for (int i = 0; i < vertices.size(); i++) {
        double x0 = vertices[i][0];
        double y0 = vertices[i][1];
        double x1 = vertices[(i + 1) % vertices.size()][0];
        double y1 = vertices[(i + 1) % vertices.size()][1];

        // Shoelace formula
        double area = (x0 * y1) - (x1 * y0);
        signed_area += area;
        centroid[0] += (x0 + x1) * area;
        centroid[1] += (y0 + y1) * area;
    }

    signed_area *= 0.5;
    centroid[0] /= 6 * signed_area;
    centroid[1] /= 6 * signed_area;

    return centroid;
}

double calculate_polygon_area(const std::vector<std::vector<double>> input_polygon) {
    if (input_polygon.size() < 3) {
        return 0.0;
    }

	int n = input_polygon.size();
    double area = 0.0;

    for (int i = 0; i < n; i++) {
		double x1 = input_polygon[i][0];
		double y1 = input_polygon[i][1];
		double x2 = input_polygon[(i + 1) % n][0];
		double y2 = input_polygon[(i + 1) % n][1];
        area += (x1 * y2) - (x2 * y1);
    }

    // Take the absolute value and divide by 2
    area = 0.5 * (area);

    return area;
}

void Mesh::find_vertex_connectivity(int vertex_index, std::vector<int>& neighborList, std::vector<int>& neighborMap) {
    std::unordered_set<int> neighboring_vertices;

    auto triangles_containing_vertex = vertex_to_triangles.find(vertex_index);
    if (triangles_containing_vertex != vertex_to_triangles.end()) {
        for (int triangle_index : triangles_containing_vertex->second) {
            const std::vector<unsigned int>& triangle = triangles[triangle_index];

            for (int j = 0; j < 3; ++j) {
                if (triangle[j] != vertex_index) {
                    neighboring_vertices.insert(triangle[j]);
                }
            }
        }

        neighborList.assign(neighboring_vertices.begin(), neighboring_vertices.end());

        std::unordered_map<int, int> neighborIndexMap;
        for (int i = 0; i < neighborList.size(); ++i) {
            neighborIndexMap[neighborList[i]] = i;
        }

        for (int triangle_index : triangles_containing_vertex->second) {
            const std::vector<unsigned int>& triangle = triangles[triangle_index];
            
            // Find the two neighbors in the triangle
            std::vector<int> other_vertices;
            for (int j = 0; j < 3; ++j) {
                if (triangle[j] != vertex_index) {
                    other_vertices.push_back(triangle[j]);
                }
            }

            if (other_vertices.size() == 2) {
                int v1_idx = other_vertices[0];
                int v2_idx = other_vertices[1];

                // Use the map for fast lookup of indices in neighborList
                neighborMap.push_back(neighborIndexMap[v1_idx]);
                neighborMap.push_back(neighborIndexMap[v2_idx]);

                std::vector<std::vector<double>> triangle_points = {
                    source_points[vertex_index],   // Current vertex
                    source_points[v1_idx],         // First neighbor
                    source_points[v2_idx]          // Second neighbor
                };
                double area = calculate_polygon_area(triangle_points);

                // Correct orientation if needed
                if (area < 0.0) {
                    std::swap(neighborMap[neighborMap.size() - 1], neighborMap[neighborMap.size() - 2]);
                }
            }
        }
    }
}

bool Mesh::is_boundary_vertex(int vertex_index, std::vector<std::pair<int, int>>& boundary_edges) {
    std::unordered_map<std::pair<int, int>, int, HashPair> edge_triangle_count;
    for (int triangle_index : vertex_adjecent_triangles[vertex_index]) {
        const std::vector<unsigned int>& triangle = triangles[triangle_index];
        for (int j = 0; j < 3; ++j) {
            int v1 = triangle[j];
            int v2 = triangle[(j + 1) % 3];
            std::pair<int, int> edge = std::make_pair(std::min(v1, v2), std::max(v1, v2));
            edge_triangle_count[edge]++;
        }
    }

    bool is_boundary = false;
    for (const auto& edge : vertex_adjecent_edges[vertex_index]) {
        if (edge_triangle_count[edge] == 1) { // Boundary edge
            boundary_edges.push_back(edge);
            is_boundary = true;
        }
    }

    return is_boundary;
}

void Mesh::build_adjacency_lookups() {
    for (int i = 0; i < source_points.size(); i++)
    {
        auto [adjacent_edges, adjacent_triangles, neighboring_vertices] = find_adjacent_elements(i);
        vertex_adjecent_edges.push_back(adjacent_edges);
        vertex_adjecent_triangles.push_back(adjacent_triangles);
        vertex_adjecent_vertices.push_back(neighboring_vertices);
    }

    for (int i = 0; i < source_points.size(); i++)
    {
        std::vector<std::pair<int, int>> boundary_edges;
        bool is_boundary = is_boundary_vertex(i, boundary_edges);
        vertex_is_boundary.push_back(is_boundary);
    }
    
    
}

std::vector<double> cross_v(std::vector<double> v1, std::vector<double> v2){
  std::vector<double> result(3);
  result[0] = v1[1]*v2[2] - v1[2]*v2[1];
  result[1] = v1[2]*v2[0] - v1[0]*v2[2];
  result[2] = v1[0]*v2[1] - v1[1]*v2[0];
  return result;
}

double dot_v(std::vector<double> a, std::vector<double> b) {
  return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

std::vector<double> mult_v(double a, std::vector<double> b) {
  return {a*b[0], a*b[1], a*b[2]};
}

std::vector<double> add_v(std::vector<double> a, std::vector<double> b) {
  return {a[0] + b[0], a[1] + b[1], a[2] + b[2]};
}

std::vector<double> sub_v(std::vector<double> a, std::vector<double> b) {
  return {a[0] - b[0], a[1] - b[1], a[2] - b[2]};
}

double magnitude_v(std::vector<double> a) {
  return std::sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2]);
}

double cot(const std::vector<double>& a, const std::vector<double>& b) {
    auto cross_product = cross_v(a, b);
    double cross_magnitude = magnitude_v(cross_product);

    if (cross_magnitude < 1e-12) {
        //throw std::invalid_argument("Vectors are parallel or one is a zero vector, cotangent undefined.");
        cross_magnitude = 1e-12;
    }

    return dot_v(a, b) / cross_magnitude;
}

std::vector<double> Mesh::compute_laplacian(int i) {
    std::vector<double> laplacian(vertex_adjecent_vertices[i].size(), 0.0f);

    for (int j_index = 0; j_index < vertex_adjecent_vertices[i].size(); ++j_index) {
        int j = vertex_adjecent_vertices[i][j_index];

        // Find triangles shared between `i` and `j`
        std::vector<int> shared_triangles;
        for (int triangle : vertex_adjecent_triangles[i]) {
          // Check if `j` is one of the vertices in this triangle
          const auto& vertices = triangles[triangle];
          if (std::find(vertices.begin(), vertices.end(), j) != vertices.end()) {
              shared_triangles.push_back(triangle);
          }
        }

        // Handle cases based on the number of shared triangles
        if (shared_triangles.size() == 2) {
            // Interior case: Two triangles are connected
            std::vector<int> k_vertices;
            for (int triangle : shared_triangles) {
                for (int vertex : this->triangles[triangle]) {
                    if (vertex != i && vertex != j) {
                        k_vertices.push_back(vertex);
                        break; // Only one `k` per triangle
                    }
                }
            }

            // Ensure we found two `k` vertices
            if (k_vertices.size() != 2) {
                throw std::runtime_error("Error identifying k vertices in triangles.");
            }

            int k1 = k_vertices[0];
            int k2 = k_vertices[1];

            std::vector<double> edge1;
            std::vector<double> edge2;

            edge1 = sub_v(this->source_points[k1], this->source_points[j]);
            edge2 = sub_v(this->source_points[k1], this->source_points[i]);
            double cot_k1 = cot(edge1, edge2);

            edge1 = sub_v(this->source_points[k2], this->source_points[j]);
            edge2 = sub_v(this->source_points[k2], this->source_points[i]);
            double cot_k2 = cot(edge1, edge2);

            laplacian[j_index] += cot_k1 * 0.5;
            laplacian[j_index] += cot_k2 * 0.5;

            //std::cout << "k1=" << k1 << ", k2=" << k2 << std::endl;

        } else if (shared_triangles.size() == 1) {
            // Boundary case: Only one triangle is connected
            int triangle = shared_triangles[0];
            int k = -1;

            // Find the single `k` vertex
            for (int vertex : this->triangles[triangle]) {
                if (vertex != i && vertex != j) {
                    k = vertex;
                    break;
                }
            }

            if (k == -1) {
                throw std::runtime_error("Error identifying k vertex in boundary triangle.");
            }

            std::vector<double> edge1;
            std::vector<double> edge2;

            edge1 = sub_v(this->source_points[k], this->source_points[j]);
            edge2 = sub_v(this->source_points[k], this->source_points[i]);
            double cot_k = cot(edge1, edge2);

            laplacian[j_index] += cot_k;

            //std::cout << "k=" << k << std::endl;

        } else {
            throw std::runtime_error("No shared triangles between i and j; invalid mesh or disconnected vertex.");
        }
    }

    return laplacian;
}

void Mesh::calculate_vertex_laplacians() {
    build_adjacency_lookups();
    vertex_laplacians.clear();
    
    for (int i = 0; i < this->source_points.size(); i++)
    {
        vertex_laplacians.push_back(compute_laplacian(i));
    }
}

void Mesh::get_vertex_neighbor_ids(int vertex_id, int &left_vertex, int &right_vertex, int &top_vertex, int &bottom_vertex) {
    int y = vertex_id / res_x;
    int x = vertex_id % res_x;

    if (x != 0) {
        left_vertex = (y) * res_x + (x - 1);
    } else {
        left_vertex = -1;
    }

    if (y != 0) {
        top_vertex = (y - 1) * res_x + (x);
    } else {
        top_vertex = -1;
    }

    if (x != res_x - 1) {
        right_vertex = (y) * res_x + (x + 1);
    } else {
        right_vertex = -1;
    }

    if (y != res_y - 1) {
        bottom_vertex = (y + 1) * res_x + (x);
    } else {
        bottom_vertex = -1;
    }
}

std::vector<double> normalize(std::vector<double> p1) {
    std::vector<double> vec(3);
    double squared_len = 0;
    for (int i=0; i<p1.size(); i++) {
        squared_len += p1[i] * p1[i];
    }

    double len = std::sqrt(squared_len);

    for (int i=0; i<p1.size(); i++) {
        vec[i] = p1[i] / len;
    }

    return vec;
}

void Mesh::save_solid_obj_source(double thickness, const std::string& filename) {
    save_solid_obj(this->source_points, this->source_points, this->triangles, thickness, this->width, this->height, this->res_x, this->res_y, filename);
}

bool Mesh::is_border(int vertex_id) {
    int y = vertex_id / res_x;
    int x = vertex_id % res_x;

    if (x == 0) {
        return true;
    }

    if (y == 0) {
        return true;
    }

    if (x == res_x - 1) {
        return true;
    }

    if (y == res_y - 1) {
        return true;
    }

    return false;
}